module.exports = [
  { name: 'add', desc: "Pops two values and pushes the sum of both.", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'add', flags: false, condition: 'always' },
  { name: 'asl', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'lsl', flags: false, condition: 'always' },
  { name: 'asr', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'asr', flags: false, condition: 'always' },
  { name: 'bpget', desc: "Pushes the current base pointer.", argc: 0, input0: 'zero', input1: 'zero', output: 'push', command: 'bpget', flags: false, condition: 'always' },
  { name: 'bpset', desc: "Pops a value and sets the base pointer to it.", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'bpset', flags: false, condition: 'always' },
  { name: 'bswap', desc: "Swaps bytes of stack top", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'bswap', flags: false, condition: 'always' },
  { name: 'call', desc: "Pops address and calls it.", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'setip', flags: false, condition: 'always' },
  { name: 'cmp', desc: "Compares two values from the stack.", argc: 0, input0: 'pop', input1: 'pop', output: 'discard', command: 'sub', flags: true, condition: 'always' },
  { name: 'cmp', desc: "Compares stack top to immediate value", argc: 1, input0: 'pop', input1: 'immediate', output: 'discard', command: 'sub', flags: true, condition: 'always' },
  { name: 'div', desc: "", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'div', flags: false, condition: 'always' },
  { name: 'dup', desc: "Duplicates the stack top", argc: 0, input0: 'peek', input1: 'zero', output: 'push', command: 'copy', flags: false, condition: 'always' },
  { name: 'frget', desc: "Pushes the current flag register.", argc: 0, input0: 'zero', input1: 'zero', output: 'push', command: 'frget', flags: false, condition: 'always' },
  { name: 'frset', desc: "Pops a value and sets the flag register to it.", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'frset', flags: false, condition: 'always' },
  { name: 'intr', desc: "Invokes the given interrupts.", argc: 1, input0: 'immediate', input1: 'zero', output: 'discard', command: 'intr', flags: false, condition: 'always' },
  { name: 'iret', desc: "Returns from a interrupt.", argc: 0, input0: 'pop', input1: 'pop', output: 'discard', command: 'setip', flags: false, condition: 'always' },
  { name: 'lsl', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'lsl', flags: false, condition: 'always' },
  { name: 'lsr', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'lsr', flags: false, condition: 'always' },
  { name: 'mul', desc: "Pops two values and pushes the product of both.", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'mul', flags: false, condition: 'always' },
  { name: 'ret', desc: "Returns from a function call.", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'setip', flags: false, condition: 'always' },
  { name: 'call', desc: "Calls immediate address.", argc: 1, input0: 'immediate', input1: 'zero', output: 'push', command: 'setip', flags: false, condition: 'always' },
  { name: 'jmp', desc: "Pops address, jumps to it.", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'setip', flags: false, condition: 'always' },
  { name: 'rol', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'rol', flags: false, condition: 'always' },
  { name: 'ror', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'ror', flags: false, condition: 'always' },
  { name: 'sgnext', desc: "Sign-extends stack top.", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'signext', flags: false, condition: 'always' },
  { name: 'cmpp', desc: "Compares stack top to immediate value, doesn't pop.", argc: 1, input0: 'peek', input1: 'immediate', output: 'discard', command: 'sub', flags: true, condition: 'always' },
  { name: 'jmp', desc: "Jumps to immediate address.", argc: 1, input0: 'immediate', input1: 'zero', output: 'discard', command: 'setip', flags: false, condition: 'always' },
  { name: 'neg', desc: "", argc: 0, input0: 'zero', input1: 'pop', output: 'push', command: 'sub', flags: false, condition: 'always' },
  { name: 'not', desc: "", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'not', flags: false, condition: 'always' },
  { name: 'add', desc: "Adds immediate to stack top.", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'add', flags: false, condition: 'always' },
  { name: 'and', desc: "", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'and', flags: false, condition: 'always' },
  { name: 'and', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'and', flags: false, condition: 'always' },
  { name: 'div', desc: "Divides stack top by immediate.", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'div', flags: false, condition: 'always' },
  { name: 'mod', desc: "Computes modulus of stack top % immediate", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'mod', flags: false, condition: 'always' },
  { name: 'mul', desc: "Multiplies immediate and stack top.", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'mul', flags: false, condition: 'always' },
  { name: 'or', desc: "", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'or', flags: false, condition: 'always' },
  { name: 'and', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'and', flags: false, condition: 'always' },
  { name: 'mod', desc: "", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'mod', flags: false, condition: 'always' },
  { name: 'or', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'or', flags: false, condition: 'always' },
  { name: 'sub', desc: "Pops two values and pushes the difference of both.", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'sub', flags: false, condition: 'always' },
  { name: 'bpset', desc: "Sets the base pointer to the immediate value.", argc: 1, input0: 'immediate', input1: 'zero', output: 'discard', command: 'bpset', flags: false, condition: 'always' },
  { name: 'frset', desc: "Sets the flag register to the immediate value.", argc: 1, input0: 'immediate', input1: 'zero', output: 'discard', command: 'frset', flags: false, condition: 'always' },
  { name: 'sub', desc: "Subtracts immediate from stack top.", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'sub', flags: false, condition: 'always' },
  { name: 'xor', desc: "", argc: 0, input0: 'pop', input1: 'pop', output: 'push', command: 'xor', flags: false, condition: 'always' },
  { name: 'or', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'or', flags: false, condition: 'always' },
  { name: 'xor', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'xor', flags: false, condition: 'always' },
  { name: 'xor', desc: "", argc: 1, input0: 'pop', input1: 'immediate', output: 'push', command: 'xor', flags: false, condition: 'always' },
  { name: 'frset', desc: "Sets the flag register to the first immediate value, where only the bits are changed that are 0 in the second immediate value.", argc: 2, input0: 'immediate', input1: 'immediate', output: 'discard', command: 'frset', flags: false, condition: 'always' },
  { name: 'get', desc: "Reads a value from BP-relative offset", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'get', flags: false, condition: 'always' },
  { name: 'set', desc: "Writes a value to BP-relative offset", argc: 0, input0: 'pop', input1: 'pop', output: 'discard', command: 'set', flags: false, condition: 'always' },
  { name: 'spget', desc: "Pushes the current stack pointer", argc: 0, input0: 'zero', input1: 'zero', output: 'push', command: 'spget', flags: false, condition: 'always' },
  { name: 'spset', desc: "Pops a value and sets the stack pointer to it.", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'spset', flags: false, condition: 'always' },
  { name: 'get', desc: "Reads a value from BP-relative offset", argc: 1, input0: 'immediate', input1: 'zero', output: 'push', command: 'get', flags: false, condition: 'always' },
  { name: 'ld', desc: "Pops address, pushes word at address", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'load16', flags: false, condition: 'always' },
  { name: 'ld8', desc: "Pops address, pushes byte at address", argc: 0, input0: 'pop', input1: 'zero', output: 'push', command: 'load8', flags: false, condition: 'always' },
  { name: 'ld', desc: "Pushes the word from the immediate address", argc: 1, input0: 'immediate', input1: 'zero', output: 'push', command: 'load16', flags: false, condition: 'always' },
  { name: 'ld8', desc: "Pushes the byte from the immediate address", argc: 1, input0: 'immediate', input1: 'zero', output: 'push', command: 'load8', flags: false, condition: 'always' },
  { name: 'nop', desc: "Does nothing", argc: 0, input0: 'zero', input1: 'zero', output: 'discard', command: 'copy', flags: false, condition: 'always' },
  { name: 'pop', desc: "Removes the stack top", argc: 0, input0: 'pop', input1: 'zero', output: 'discard', command: 'copy', flags: false, condition: 'always' },
  { name: 'push', desc: "Pushes a value", argc: 1, input0: 'immediate', input1: 'zero', output: 'push', command: 'copy', flags: false, condition: 'always' },
  { name: 'replace', desc: "Removes the stack top and pushes a value", argc: 1, input0: 'immediate', input1: 'pop', output: 'push', command: 'copy', flags: false, condition: 'always' },
  { name: 'set', desc: "Writes a value to BP-relative offset", argc: 1, input0: 'immediate', input1: 'pop', output: 'discard', command: 'set', flags: false, condition: 'always' },
  { name: 'spset', desc: "Sets the stack pointer to the immediate value.", argc: 1, input0: 'immediate', input1: 'zero', output: 'discard', command: 'spset', flags: false, condition: 'always' },
  { name: 'set', desc: "Writes a value to BP-relative offset", argc: 2, input0: 'immediate', input1: 'immediate', output: 'discard', command: 'set', flags: false, condition: 'always' },
  { name: 'st', desc: "Pops word and address, stores it.", argc: 0, input0: 'pop', input1: 'pop', output: 'discard', command: 'store16', flags: false, condition: 'always' },
  { name: 'st8', desc: "Pops byte and address, stores it.", argc: 0, input0: 'pop', input1: 'pop', output: 'discard', command: 'store8', flags: false, condition: 'always' },
  { name: 'st', desc: "Pops a word and stores it at the immediate address", argc: 1, input0: 'pop', input1: 'immediate', output: 'discard', command: 'store16', flags: false, condition: 'always' },
  { name: 'st', desc: "Stores immediate word at immediate address.", argc: 2, input0: 'immediate', input1: 'immediate', output: 'discard', command: 'store16', flags: false, condition: 'always' },
  { name: 'st8', desc: "Pops a byte and stores it at the immediate address", argc: 1, input0: 'pop', input1: 'immediate', output: 'discard', command: 'store8', flags: false, condition: 'always' },
  { name: 'st8', desc: "Stores immediate byte at immediate address.", argc: 2, input0: 'immediate', input1: 'immediate', output: 'discard', command: 'store8', flags: false, condition: 'always' },
];
