(19:56:58) Jonathan: Moin
(20:49:16) Jonathan: Hm... Macht Linux mit 15MB RAM Sinn? *g*
(21:04:33) MasterQ32: lar
(21:04:34) MasterQ32: *klar
(21:10:10) Jonathan: Ich glaube, das Projekt "32 Bit CPU mit 8 Bit Mikroarchitektur" wird wohl bald wahr
(21:10:43) Jonathan: Wird vermutlich ne ARM-CPU, nur beim RAM bin ich mir noch unsicher :D
(21:11:48) Jonathan: 30-Pin oder 72-Pin SIMMs? :D
(21:13:14) MasterQ32: :D
(21:13:17) MasterQ32: duu spinnst doch :D
(21:13:23) Jonathan: Wieso? :P
(21:13:40) Jonathan: 30-Pin SIMMs sind schön mit 2,54mm-Raster, die kann man super manuell verlöten
(21:13:59) Jonathan: 72-Pin SIMMs haben leider 1,27mm-Raster, dafür viel höhere Kapazitäten
(21:14:44) MasterQ32: ich werde jetzt wahrscheinlich doch I²C als On-Chip-Bus nehmen und nicht auf Svenskas rat hren und SPI nehmen ^^ 
(21:15:16) Jonathan: Oweh :P
(21:15:29) MasterQ32: naja, ich habs versucht und bin gescheitert
(21:15:37) Jonathan: Ich hätte 15x 1MB 30-Pin SIMM
(21:15:39) MasterQ32: obwohl das doch nur zwei register aufm AVR sind ^^
(21:15:46) Jonathan: Und 4x 32MB 72-Pin SIMM
(21:16:00) Jonathan: *g*
(21:16:14) MasterQ32: naja, ich muss doch alle pins nur name-by-name miteinander verbinden, oder?
(21:16:25) Jonathan: Öööh, bei SPI?
(21:16:28) MasterQ32: jau
(21:16:40) MasterQ32: und den chipselect dauerhaft auf HIGH am master, am client eben auf low ziehen, wenn ich was schicken will
(21:16:42) Jonathan: "MOSI"... "Master Out Slave In"
(21:17:10) MasterQ32: genau. das MOSI-Master sollte ja an das MOSI-Client 
(21:17:21) MasterQ32: und mit MISO vice versa
(21:17:34) Jonathan: Hast du denn auch die SPI-Hardware passend initialisiert?
(21:17:42) MasterQ32: straight aus dem datenblatt
(21:17:57) Jonathan: Guck mal mit nem Scope drauf? :D
(21:18:03) MasterQ32: hab ich keines ^^
(21:18:09) Jonathan: Autsch *g*
(21:18:20) MasterQ32: beim master SPCR += SPE,MSTR,SPR0, beim client mit SPE
(21:20:45) MasterQ32: also eigentlich nur einmal "ich brauch nen master, f/16 taktrate und der client ist einfach SPI an
(21:21:43) MasterQ32: ich dreh mal noch die taktrate runter
(21:23:16) MasterQ32: oh
(21:23:17) MasterQ32: hau mcih
(21:23:20) MasterQ32: *hau mich
(21:24:43) Jonathan: Oh? :P
(21:25:10) Jonathan: Ich war übrigens kurz davor, 16 Stück AS6C4008 zu kaufen, aber bei dem Preis hab ich dann doch lieber zweimal nach meinen alten SIMMs gesucht *g*
(21:25:35) MasterQ32: taktrate auf 1/128*fᶜᵖᵘ anstelle von 1/16*fᶜᵖᵘ
(21:25:41) MasterQ32: hihi :D
(21:26:34) Jonathan: Geht's jetzt? :P
(21:27:27) MasterQ32: https://pastebin.com/6GZw4sXU
(21:27:31) MasterQ32: sieht doch gut aus, oder
(21:27:32) MasterQ32: ?
(21:27:50) MasterQ32: der client zeigt den übertragenen wert aufm display an und liefert einen zählwert zurück :)
(21:28:19) MasterQ32: afkagain
(21:29:09) Jonathan: Klingt gut :P
(21:29:16) MasterQ32: denk ich auch
(21:30:03) MasterQ32: aber ich würde gerne eine ordentliche lese/schreib-semantik haben, hast du mir da ne gute idee?
(21:31:44) MasterQ32: bin wieder afk, würde mich über deine geistigen ergüsse freuen :)
(21:36:12) Jonathan: Öööh, Lesen/Schreiben von was überhaupt?
(21:36:23) MasterQ32: oh :D
(21:36:25) MasterQ32: I/O-Geräten
(21:36:37) MasterQ32: an dem SPI klemmen jetzt I/O-Geräte
(21:36:47) MasterQ32: diese möchte ich ähnlich der z80 in/out-semantik ansteuern
(21:40:31) Jonathan: Ah, achso :P
(21:40:40) MasterQ32: joar
(21:40:48) MasterQ32: ich finde SPI irgendwie unintuitiv
(21:41:00) Jonathan: Naja, Adresse und Daten vom Stack nehmen? Oder so?
(21:41:07) Jonathan: Wo genau ist das Problem? :D
(21:41:15) MasterQ32: immer übertragen und empfangen gleichzeitig widerspricht im moment meiner logik :D
(21:42:08) Jonathan: Ah *g*
(21:42:32) MasterQ32: kannst du mir da ein wenig helfen?
(21:42:33) MasterQ32: :D
(21:42:42) Jonathan: Du könntest genau so gut einfach die SPI-Steuerregister vom AVR an deine simulierte CPU durchreichen
(21:43:03) MasterQ32: ja, das meinte svenska auch, aber das widerspricht meinem projektziel ^^
(21:43:14) MasterQ32: wie mach ich da bleistiftsweise einen display-controller-proto?
(21:43:28) MasterQ32: ich selektiere den controller und schreibe dann welche daten? ^^
(21:43:35) Jonathan: Huh?
(21:43:52) Jonathan: Naja, das Display steuerst du dann eben im Code deiner eigenen CPU an?
(21:44:44) Jonathan: https://pastebin.com/rRXmpgFQ *g*
(21:45:17) MasterQ32: deine teile-liste? :)
(21:45:46) Jonathan: Ja... :P
(21:45:55) Jonathan: Wie gesagt, diskrete ARM-CPU
(21:46:01) Jonathan: Das wird lustig ;)
(21:46:05) MasterQ32: du wahnsinniger :D
(21:46:44) MasterQ32: ja, aber wie sieht so ein protokoll dann aus? ich hab ja im display befehlsport und datenport
(21:47:11) MasterQ32: die würde ich gerne irgendwie über das SPI wegabstrahieren
(21:49:27) Jonathan: Das abstrahierst du alles in deinem Code auf der Eigenbau-CPU
(21:49:37) MasterQ32: wie meinst?
(21:49:44) Jonathan: Niemand hindert dich daran, dort ein paar Funktionen wie "displayWriteCommand" etc zu definieren
(21:49:57) Jonathan: Das ist sehr viel sauberer, als das im AVR zu realisieren
(21:50:05) Jonathan: Denn du willst vermutlich später nicht nur ein Display da dran hängen
(21:50:32) Jonathan: Deine simulierte CPU sollte so viel Kontrolle über den SPI-Bus haben, wie möglich, und das ist eben der Fall, wenn sie die SPI-Register lesen/schreiben kann
(21:51:40) MasterQ32: ah, warte
(21:52:02) MasterQ32: damit ich nicht in die gleiche diskussion wie mit svenska gestern renne
(21:52:15) MasterQ32: dieses LCD hängt an einem AVR, der das Display-Device darstellt
(21:52:54) MasterQ32: dies soll von der CPU aus über eine adresse angesprochen werden, nicht über ein "konkretes SPI"
(21:53:07) MasterQ32: ansonsten kann ich ja auch gleich SPI-instruktionen in die CPU bauen
(21:53:22) Jonathan: Vielleicht wäre es dann besser, wenn du das Display direkt an den einen AVR dran hängst?
(21:53:27) Jonathan: Ist es ein HD44780?
(21:53:30) MasterQ32: ja, ist es
(21:53:40) MasterQ32: aber: ich möchte ja $viele Devices an den AVR hängen
(21:53:47) Jonathan: Das kannst du ja auch
(21:53:55) Jonathan: Häng das Display einfach in den Adressraum vom RAM
(21:54:01) Jonathan: Memory-Mapped I/O und so
(21:54:13) MasterQ32: hm, hab ich mir auch schon überlegt
(21:54:20) MasterQ32: aber dann muss ich immer noch nen KBC basteln
(21:54:25) Jonathan: Die 8 Datenleitungen zwischen RAM und AVR klemmst du  am Display an, die Read/Write-Leitungen auch
(21:54:29) MasterQ32: der auch mit der geschwindigkeit vom rambus mitkommt
(21:54:44) Jonathan: Naja, es gibt da den i8042 :P
(21:54:56) MasterQ32: ^^
(21:55:07) MasterQ32: und massenspeicher-geräte usw halt auch
(21:55:13) MasterQ32: zum beispiel nen SD-Karten-Interface
(21:55:51) MasterQ32: bei SPI hab ich halt irgendwo das Problem, dass ich nur eine "geräteadresse" vergeben kann, was ja bei MMIO nicht brauche
(21:56:05) MasterQ32: aber bei MMIO sterb ich den leitungstod, wenn ich custom hardware basteln will
(21:56:11) MasterQ32: mein steckbrett ist jetzt schon voll
(21:56:17) Jonathan: Wie gesagt, dein HD44780 ist dafür geeignet, in einen Bus reingehäkelt zu werden
(21:56:23) Jonathan: Also solltest du das wohl tun
(21:56:25) MasterQ32: ja, das ist mir durchaus bewusst ^^
(21:56:27) Jonathan: :P
(21:56:42) Jonathan: Du kannst ja später noch SPI machen (und dann auch wirklich die SPI-Register an deine CPU geben)
(21:56:50) MasterQ32: hm
(21:57:04) Jonathan: Und ein ROM würde ich auch noch in den Adressraum rein hängen
(21:57:07) MasterQ32: dann würde ich eher nen externes SPI-Device basteln und auch an den Datenbus klemmen
(21:57:21) MasterQ32: ich wüsste halt grade nicht, wie ich nen ROM brennen soll
(21:57:21) Jonathan: Wie du willst :P
(21:57:26) Jonathan: Achso
(21:57:43) Jonathan: Naja, jedenfalls wäre ein WAIT-Signal für deinen Bus auch noch ganz sinnvoll
(21:57:47) MasterQ32: und ne "grafikkarte" soll da auch noch irgendwie ran
(21:57:52) Jonathan: Ääääh ja
(21:58:01) Jonathan: Für die "Grafikkarte" brauchst du dann sowieso MMIO *g*
(21:58:09) MasterQ32: hm
(21:58:39) MasterQ32: und dann brauch ich auch gleich noch ne MMU :D
(21:58:51) Jonathan: Das kann dein AVR machen :P
(21:58:55) MasterQ32: joar
(21:58:56) Jonathan: (Also der "Haupt-AVR")
(21:59:00) MasterQ32: der CPU-AVR :D
(21:59:01) Jonathan: Ist ja nur Code :P
(21:59:14) MasterQ32: theoretisch kann ich ja auch das Rohm in den AVR brennen
(21:59:24) MasterQ32: 2kB EEPROM oder halt direkt in den flash
(21:59:38) MasterQ32: da sind ja so 16kB platz
(22:00:08) MasterQ32: hm
(22:00:24) MasterQ32: ich müsste dann wohl das projekt etwas umdesignen, aber irgendwie gefällt mir die idee mit dem BUS schon recht
(22:00:43) Jonathan: Ja :P
(22:01:10) Jonathan: Und 2kB EEPROM klingen doch ganz nett für ein Boot-ROM
(22:01:29) MasterQ32: ah, ist doch nur 1 kB
(22:02:57) MasterQ32: aber dann hab ich ja auf dem Bus { 24 bit adressbus, 8 bit datenbus, ReadEnable, WriteEnable, HoldBus }
(22:03:28) MasterQ32: gibts irgendwie praktische adress-decoder für sowas? :D
(22:03:59) MasterQ32: weil ich möchte ja dann die einzelnen geräte passend enablen/disablen
(22:04:57) MasterQ32: das LCD braucht ja beispielsweise nur 2 byte speicher, da wäre es vielleicht sinnvoll, für die I/O-Geräte doch noch nen eigenes system zu basteln
(22:06:18) MasterQ32: wenn ich sage: 4kB page-größe, hab ich ja 16 "page slots", in denen ich mein aktuelles "speicherbild" organisieren kann
(22:07:39) MasterQ32: und ich fänds irgendwie für die "einfachheit" der i/o-geräte sinnvoll, die nur über eine 16-bittige granularität ansprechen zu können und die unteren 8 bit sind quasi immer komplett für ein device vergeben
(22:08:04) MasterQ32: hm, dann hätte ich aber irgendwie pagegröße != device-page-größe
(22:08:06) MasterQ32: *blubber*
(22:08:07) Jonathan: MasterQ32: Natürlich gibt's dafür Adressdekoder...
(22:08:12) Jonathan: 74HCT688
(22:08:13) MasterQ32: macht das irgendwie sinn, was ich da grade von mir gebe?
(22:08:22) Jonathan: Und 74HCT154
(22:08:52) Jonathan: '688 ist ein 8-Bit-Komparator (vergleicht zwei 8-Bit-Werte an seinen Eingängen und sagt, wenn sie gleich sind)
(22:09:14) Jonathan: '154 ist ein 4-zu-16-Dekoder (nimmt 4 Bit und aktiviert dann eine von 16 Ausgangsleitungen)
(22:09:29) Jonathan: Ersterer ist gut für einzelne Devices, die irgendwo im Adressraum rumfliegen
(22:09:44) Jonathan: Letzterer ist gut für "Blöcke" von Registern im Adressraum
(22:10:09) MasterQ32: okay, verständlich
(22:10:34) mgottschlag left the room (quit: Client exited).
(22:10:51) Jonathan: Und es spricht nichts dagegen, einem Device mehr als eine Page zuzuordnen
(22:11:10) Jonathan: Wenn das Device weniger braucht, dann nutzt es eben weniger
(22:11:11) Jonathan: Ah, und:
(22:11:31) Jonathan: Wenn du mit den oberen 8 Bit das Device auswählst und im Device dann z.B. nur 16 Register hast, musst du die verbleibenden 12 Bit natürlich nicht dekodieren
(22:12:03) Jonathan: [8 Bit Auswahl von Device (oder RAM)][12 Bit ungenutzt][4 Bit Registernummer]
(22:12:25) Jonathan: Dann sind die Register des Device zwar über mehrere Adressen erreichbar, aber wen stört das?
(22:12:41) MasterQ32: naja, ich hätte jetzt eher [16 bit auswahl device][8 bit Register] gemacht
(22:12:47) MasterQ32: oder ist das dämlich?
(22:12:54) MasterQ32: damit würde ich nicht SO viel space wasten :D
(22:13:04) MasterQ32: dein vorschlag wasted ja beim LCD 64kB-2
(22:13:14) Jonathan: 1. So viele Devices wirst du nicht haben, 2. Du hast auch SO viel "Space zu wasten", 3. Denk mal an die Grafikkarte
(22:13:32) Jonathan: Angenommen, du teilst das so auf:
(22:14:29) Jonathan: 0x00 00 00 ... 0x7F FF FF = (potentiell) RAM
(22:14:40) Jonathan: 0x 80 00 00 ... 0x FF FF FF = (potentiell) Device
(22:15:00) Jonathan: Das oberste Byte im "Device"-Teil des Adressraums wählt eins von maximal 128 Devices
(22:15:11) Jonathan: Und die unteren 16 Bit der Adresse sind dann für das Device
(22:15:41) Jonathan: Dann hast du maximal 8MB RAM und maximal 128 Devices zu je 64kB Adressraum
(22:15:49) Jonathan: Das ist eine durchaus sehr sinnvolle Unterteilung :P
(22:16:47) Jonathan: Den Chipselect für den RAM kannst du dann einfach aus dem obersten Bit der Adresse generieren, den Chipselect für ein Device erzeugst du mit nem '688 aus dem obersten Byte
(22:17:07) MasterQ32: okay, damit hast du mich überzeugt <3
(22:17:11) MasterQ32: http://www.ti.com/lit/ds/symlink/cd74hct688.pdf
(22:17:13) MasterQ32: den hier meinst du, oder?
(22:17:23) Jonathan: Du kannst sogar 8er DIP-Switches auf jedes Device kleben, mit dem du den Vergleichswert für den '688 einstellen kannst, dann kannst du die Devices beliebig im Adressraum verteilen (und nichts ist festgelegt)
(22:17:39) Jonathan: Ja, genau den Chip :P
(22:18:01) Jonathan: Der hat einfach zwei 8-Bit-Eingänge, A und B, und er verrät dir, wann A == B
(22:18:11) MasterQ32: joar, ich sehs ja grade
(22:18:13) Jonathan: Super gut für Adress-Vergleiche geeignet :P
(22:18:19) MasterQ32: und das mit den dip-switches finde ich sehr sinnvoll :D
(22:18:23) Jonathan: *g*
(22:18:31) MasterQ32: dann hab ich pro device einen dip-switch
(22:18:45) Jonathan: Klebst einen 8er-DIP-Switch an Eingang A vom '688, die obersten 8 Adressbits an Eingang B
(22:18:53) MasterQ32: und die grafikkarte mappt halt 128kB oder so
(22:18:59) MasterQ32: jop
(22:19:08) Jonathan: Joa, dann belegt die GraKa eben zwei Slots
(22:19:13) MasterQ32: jop
(22:19:22) Jonathan: Oder mehr, musst ja nur ein paar Eingänge vom '688 dafür auf 0 setzen
(22:19:27) MasterQ32: was bietet sich als hardware für nen bus an? Europlatine Streifenmuster und Steckverbinder?
(22:19:30) MasterQ32: jau
(22:20:03) Jonathan: Europlatine Punktraster (Epoxy! Hartpapier ist SCHEISSE!) + dicke Flachbandkabel und Wannenstecker
(22:20:34) Jonathan: Mein (inzwischen aufgegebenes, weil beschissen zu programmierendes) i8088-System hat den Bus über ein 50-poliges Flachbandkabel laufen
(22:20:46) Jonathan: Oh, ach ja
(22:20:55) MasterQ32: dicke oder *breite* flachbandkabel? :D
(22:20:58) Jonathan: Von Bank Switching / Nicht-flachem Speicher bin ich inzwischen geheilt *g*
(22:21:01) XanClic [~maxx@xanclic.absolute-chefkekse.de] entered the room.
(22:21:01) #lost: mode (+o XanClic) by ChanServ
(22:21:05) MasterQ32: wie meinst?
(22:21:12) Jonathan: Ich will das Zeug nie wieder anfassen
(22:21:16) Jonathan: Das ist unglaublich eklig
(22:21:26) Jonathan: Deshalb meinte ich ja, du sollst lieber mit 32-Bit-Adressen arbeiten
(22:21:33) Jonathan: Und dann nur einen flachen Adressraum haben
(22:21:44) MasterQ32: ich brauch ja irgendwie ne möglichkeit, die 8 MB rahm mit meinen 16 bit zu adressieren
(22:21:57) Jonathan: Richtig, und die Möglichkeit nennt sich Bank Switching
(22:22:14) Jonathan: Bei meinem Z80-Rechner waren es 64k --> 4M
(22:22:26) MasterQ32: okay, also n bänke, welche 16/n kB größe haben
(22:22:33) Jonathan: *64/n
(22:22:34) Jonathan: Aber ja
(22:22:37) MasterQ32: stimmt :D
(22:22:40) Jonathan: Bei meinem Z80-System war n=4
(22:22:44) MasterQ32: weil irgendwie muss ja auch an meine devices kommen ^^
(22:22:51) Jonathan: Und ich will dir eins raten:
(22:22:53) Jonathan: Tu das nicht
(22:22:57) MasterQ32: 4 scheint typisch zu sein, ich glaube aber, feingranularer ist besser, oder?
(22:23:01) Jonathan: Ja, feiner ist besser
(22:23:10) MasterQ32: segmentierung besser als banking?
(22:23:11) Jonathan: Aber bitte, bitte
(22:23:14) MasterQ32: ^^
(22:23:18) Jonathan: Nein, Segmentierung ist genau so beschissen
(22:23:24) Jonathan: Deshalb ist das i8088-System aufgegeben
(22:23:43) MasterQ32: ich persönlich finde banking relativ intuitiv, aber ich sehe durchaus auch die probleme
(22:24:01) MasterQ32: PIC ist da beispielsweise fast pflicht
(22:24:05) Jonathan: Die Probleme nennen sich dann z.B. "modsys_invoke"...
(22:24:16) MasterQ32: was wäre das?
(22:24:28) Jonathan: Die Funktion machte in meinem OS einen CALL in einen ausgeblendeten Treiber
(22:24:34) Jonathan: Musste ihn also per Bank Switching einblenden etc.
(22:25:03) Jonathan: Der ganze Spaß musste natürlich auch rekursiv funktionieren
(22:25:19) Jonathan: Und weil es noch nicht schlimm genug ist: Ich musste den ganzen Stack nehmen und per Bank Switching wo anders einblenden
(22:25:25) Jonathan: Genauso den Datenpuffer für den Treiber-Aufruf
(22:25:48) Jonathan: Das hat zwar irgendwie funktioniert, war aber unglaublich beschränkt und ein absoluter Albtraum zu programmieren
(22:26:33) MasterQ32: okay, ja
(22:26:35) MasterQ32: i see
(22:26:43) MasterQ32: TI-OS hat das mit nem farjump gelöst
(22:27:02) MasterQ32:     int 0x80
(22:27:02) MasterQ32: .dw $B00B
(22:27:31) Jonathan: Effektiv war "modsys_invoke" nichts anderes
(22:27:45) Jonathan: Musste sich aber eben auch um die Übergabe von Parametern (insbesondere eines Puffers) kümmern
(22:28:01) MasterQ32: also parameterübergabe an sich geht ja bei mir trivial durch stackarchitektur
(22:28:21) Jonathan: Klar, aber, äh...
(22:28:32) Jonathan: Bitte leg den Stack in den normalen RAM? *g*
(22:28:37) MasterQ32: ja, ich grübel darüber nach
(22:28:53) MasterQ32: dem stack kann ich ja theoretisch ein eigenes "segment" verpassen
(22:29:04) MasterQ32: und damit muss der nicht im RAM eingeblendet sein, um ihn zu verwenden
(22:29:18) MasterQ32: brb
(22:29:31) Jonathan: "Eingeblendet sein" war der ganze Zweck davon, ihn in den RAM zu legen :P
(22:29:35) Jonathan: Ohne Stack im RAM kein C
(22:30:10) Jonathan: Bzw. jeder Funktionsaufruf mit irgendeiner Art von Puffer (Strings, Dateizugriffe, etc) hieße dann ein malloc
(22:30:19) Jonathan: Das willst du garantiert nicht :D
(22:34:11) Jonathan: https://pastebin.com/ppSTbtu5
(22:39:13) Jonathan: So... 80€ Logikchips finden dann wohl demnächst den Weg zu mir *g*
(22:39:58) MasterQ32: Jonathan: naja, aber ich brauch ja in allem assembler-kram den stack NICHT in den rahm eingeblendet
(22:40:08) MasterQ32: und damit halt ich mir meinen adressspace frei
(22:40:14) MasterQ32: zudem: wer sagt, dass ich in c coden will? :D
(22:40:29) Jonathan: Nein, du brauchst auch in Assembler den Stack im RAM
(22:40:36) Jonathan: Und sei es für printf ;)
(22:40:51) MasterQ32: wieso für printf? :D
(22:41:01) Jonathan: Außer, du willst *überhaupt nicht* mit lokalen Arrays etc. arbeiten
(22:41:18) MasterQ32: lokale arrays müssen halt fixed-size sein
(22:41:33) Jonathan: Das ist nicht mal das Problem
(22:41:46) Jonathan: Das Problem ist, dass du auf lokale Arrays nicht mit normalen Pointern zugreifen kannst
(22:42:03) MasterQ32: hm
(22:42:06) MasterQ32: ich denk mal drüber nach
(22:42:14) Jonathan: fwrite --> nope
(22:42:21) Jonathan: fputs --> nope
(22:42:33) Jonathan: fread, fgets --> nope, wirst du niemals haben
(22:42:44) Jonathan: printf --> nö
(22:42:47) MasterQ32: who needs that posix anyways :D
(22:42:53) MasterQ32: bzw. c
(22:42:54) Jonathan: Auweia :P
(22:43:04) MasterQ32: nein, ernsthaft
(22:43:10) Jonathan: strncpy? Auch nicht
(22:43:10) MasterQ32: ich möchte kein C auf dem gerät
(22:43:24) Jonathan: memcpy? Nö
(22:43:44) MasterQ32: du, ich hab das durchaus kapiert ^^
(22:43:47) Jonathan: :P
(22:44:04) Jonathan: "Kein C" kannst du auch als "Keine beliebige Hochsprache" schreiben
(22:44:13) MasterQ32: so what? :D
(22:44:19) Jonathan: Ohje *g*
(22:44:24) MasterQ32: BASIC und ASM reichen mir doch völlig :D
(22:44:35) Jonathan: BASIC ohne String-Verarbeitung?
(22:44:49) MasterQ32: kann doch nen string-allocator haben
(22:44:56) Jonathan: Na auweia
(22:44:59) MasterQ32: aufm TI-83+ läuft das auch super ohne stackvariablen
(22:45:19) MasterQ32: du brauchst den stack auf dem ding eh nur für eine sache: saven von registern
(22:45:40) Jonathan: Nagut, dann tu aber wenigstens eine Sache:
(22:45:54) Jonathan: Gib dem Ding zusätzlich zum Stack ein paar optional nutzbare Register
(22:46:15) Jonathan: Einfach sowas RGET/RPUT und ein paar Register dafür, das reicht schon
(22:46:26) MasterQ32: hm, dafür kann ich doch einfach speicher nehmen: P
(22:46:28) MasterQ32:  :P
(22:46:48) Jonathan: Sollte schon direkt in einem Befehl les- und schreibbar sein :P
(22:46:52) MasterQ32: wofür würdest du die denn nutzen?
(22:47:23) Jonathan: Wenn ich einen Compiler auf deinem System schreiben wollen würde, würde ich die für einige globale Pointer benutzen
(22:47:40) MasterQ32: hm
(22:47:51) MasterQ32: würde ich persönlich im speicher ablegen
(22:47:59) Jonathan: Insbesondere würde ich einen zweiten Stack anlegen, im RAM *g*
(22:48:01) MasterQ32: ^^
(22:48:10) Jonathan: Darauf würde dann alles landen, worauf ich Pointer brauche
(22:48:17) MasterQ32: der stack für lokale arrays :D
(22:48:31) Jonathan: Nicht nur lokale Arrays, auch z.B. Struct-Pointer etc.
(22:49:06) MasterQ32: naja, du kannst aber zum bleistift auf lokale arrays zugreifen, solange du nur lokalen zugriff machst
(22:49:08) MasterQ32: das geht schon
(22:49:26) Jonathan: Klar, aber ich kann eben überhaupt gar keine Pointer auf lokale Variablen übergeben
(22:49:34) MasterQ32: jo
(22:49:34) Jonathan: Ob das Arrays, Structs oder einfach nur Integer sind
(22:49:50) Jonathan: Das ist schon eine extreme Einschränkung und macht Hochsprachen so ziemlich unmöglich
(22:50:05) MasterQ32: ich bin damit zufrieden, dass die einschränkung existiert
(22:50:21) Jonathan: Naja... Mach du nur, aber ich werde dieses System nicht anfassen *g*
(22:50:24) MasterQ32: :D
(22:50:36) MasterQ32: naja, du wirst es ja auch nicht nachbauen wollen, oder? :D
(22:50:42) MasterQ32: hast doch selber genug ideen dafür
(22:50:47) MasterQ32: was eigenes
(22:51:39) MasterQ32: aber wenn ich halt den stack in den ram lege, kann ich das ding gleich in die tonne treten, was performance angeht, weil ich halt pro befehl mindestens 4 cycles mehr brauche als bisher, selbst wenn der nur stacktop duplizieren möchte
(22:51:54) MasterQ32: weil halt zwei read für peek und zwei write für push
(22:53:41) Jonathan: Wieso denn mehr?
(22:53:57) Jonathan: Du hast doch sowieso eine Multi-Cycle-Architektur, oder führst du gleichzeitig mit dem Stack-Zugriff auch einen RAM-Zugriff aus?
(22:54:06) Jonathan: Oder ist dein Stack ein Dual-Port-RAM? Glaube ich auch nicht
(22:54:38) MasterQ32: naja, ich brauch grade für einen pop einen cycle, weil der "interne ram" für den stack 16 bit datenbreite hat
(22:54:53) Jonathan: Ach, es geht um die Datenbreite ;)
(22:55:05) Jonathan: Ehrlich gesagt hab ich mich gewundert, wieso du den normalen RAM nicht mit 16 Bit angebunden hast
(22:55:22) MasterQ32: weil ich das persönlich sehr sehr weird finde ^^
(22:55:45) MasterQ32: und es mir bei quasi allem, was ich mit speicher machen möchte, irgendwie masking und ähnliches brauche, um 8 bit zu lesen
(22:56:00) MasterQ32: und ich dann keinen byte-aligned access mehr hätte (oder beißt sich das nicht?)
(22:56:11) Jonathan: 8 Bit lesen = 16 Bit lesen und die Hälfte wegwerfen?
(22:56:33) MasterQ32: okay, und ich hab nen 16 bit breiten ram aber byte-weise accessible?
(22:56:45) MasterQ32: ansonsten bräuche ich ja instructions für highbyte/lowbyte und wieder mehr dekodierungslogik
(22:56:59) Jonathan: Oder du machst Read-Modify-Write
(22:57:07) Jonathan: 16-Bit unaligned musst du nicht zulassen
(22:57:19) MasterQ32: naja, ich würde ja gerne byte-aligned access haben
(22:57:53) Jonathan: Du könntest auch einfach die paar Prozent Performance von 8-Bit-Zugriffen auf den Stack ignorieren ;)
(22:58:44) MasterQ32: naja im moment hab ich ja mindestens zwei bis max. sechs zugriffe auf den RAM
(22:58:55) Jonathan_ [~Jonathan@euirc-942754b0.dip0.t-ipconnect.de] entered the room.
(22:59:00) MasterQ32: wenn ich noch den stack mit reinpacke, lande ich bei zwei bis 10
(22:59:13) Jonathan_: Hm doof, Verbindung sagte gerade "nö"
(22:59:15) Jonathan_: Einen Moment :D
(22:59:18) Jonathan left the room (quit: Killed (NickServ (GHOST command used by Jonathan_))).
(22:59:33) Jonathan_ left the room (quit: Life is too short...).
(22:59:43) Jonathan [~Jonathan@euirc-942754b0.dip0.t-ipconnect.de] entered the room.
(22:59:43) #lost: mode (+v Jonathan) by ChanServ
(22:59:53) MasterQ32: > naja im moment hab ich ja mindestens zwei bis max. sechs zugriffe auf den RAM
(22:59:59) Jonathan: So, nun aber
(23:00:24) MasterQ32: und wenn ich halt den stack in den RAM verlager, werden das zwei bis zehn, aber mit einer stark verschoben zugriffshäufigkeit
(23:01:22) Jonathan: Naja...
(23:01:36) Jonathan: Sieh es so: Wenn du Geschwindigkeit haben wollen würdest, würdest du keine Stack-Maschine bauen *g*
(23:01:42) MasterQ32: :D
(23:01:53) MasterQ32: ich brauch ja aber auch nicht unnötige steine in den weg schmeißen
(23:02:08) Jonathan: Klar, aber momentan wirfst du dem Programmierer nicht Steine, sondern Berge in den Weg
(23:03:30) Jonathan: Wenn man für jeden Aufruf von sowas wie printf erst mal ein malloc braucht, klingt auch "-75% weniger Instruktionen pro Takt, aber dafür Pointer auf lokale Variablen" sehr attraktiv :P
(23:03:46) MasterQ32: wieso brauch ich für ein prinft ein malloc?
(23:03:50) Jonathan: Effektiv werden deine Programme dadurch eher schneller, als langsamer
(23:03:53) Jonathan: Naja...
(23:04:19) Jonathan: Entweder, du benutzt einen fixen globalen Puffer (igitt und meistens nicht möglich), oder einen Puffer auf dem Heap
(23:04:34) MasterQ32: meinst du sprintf oder printf?
(23:04:41) Jonathan: Äääh sprintf natürlich
(23:04:45) MasterQ32: ah
(23:05:14) Jonathan: Aber printf kannst du dir sowieso nicht programmieren auf der Architektur
(23:05:19) Jonathan: atoi wäre nicht möglich
(23:05:28) MasterQ32: itoa hab ich schon implementiert
(23:05:35) Jonathan: Ääääh ja, meine itoa
(23:05:41) MasterQ32: fehlt grade nur das buffer reversal am ende
(23:05:48) Jonathan: Gibt es ein itoa_stack und ein itoa_ram? ;)
(23:05:53) MasterQ32: nö
(23:05:59) Jonathan: Also nur ein itoa_stack?
(23:06:07) MasterQ32: nur itoa(ram)
(23:06:19) Jonathan: Und wie willst du dann printf implementieren? Das braucht itoa_stack
(23:06:29) Jonathan: Oder eben ein malloc vor jedem Aufruf von itoa
(23:07:07) MasterQ32: why?
(23:07:20) Jonathan: Naja, wie sonst willst du denn itoa lokal innerhalb von printf aufrufen?
(23:07:29) MasterQ32: mit nem statischen puffer
(23:07:31) MasterQ32: und jut
(23:07:38) Jonathan: ... *g*
(23:07:50) Jonathan: Okay, und angenommen, du willst irgendwas sortieren? :D
(23:08:15) Jonathan: Ohne lokale Zwischenpuffer wird das gar nichts (ist ja rekursiv)
(23:08:40) Jonathan: Also, wenn du jetzt nicht gerade sowas wie Bubblesort benutzt
(23:09:05) MasterQ32: hm
(23:09:16) MasterQ32: ja, ich grübel mal drüber nach
(23:09:35) Jonathan: Tu dir bitte einfach den Gefallen und leg den Stack in den RAM... :P
(23:09:35) MasterQ32: gibt aber doch auch rekursive inplace-sortierverfahren :)
(23:09:42) Jonathan: Quicksort?
(23:09:47) Jonathan: Das ist auch O(n^2)
(23:10:38) MasterQ32: mh
(23:11:07) Jonathan: Außerdem: Willst du darauf mal irgendein OS am Laufen haben?
(23:11:10) MasterQ32: joar
(23:11:24) MasterQ32: ich glaube, die restlichen 32 instruktionen gehen dann wohl für speichermanagement drauf ^^
(23:11:24) Jonathan: Dann wird das ohne Pointer aufn Stack nix *g*
(23:11:42) MasterQ32: ach, geht sicherlich
(23:11:51) Jonathan: Oweh. :P
(23:12:15) MasterQ32: weißt du, es gibt auch betriebssysteme für architekturen ohne stack
(23:12:27) MasterQ32: die können damit auch keinen pointer auf den stack machen
(23:12:32) MasterQ32: :P
(23:12:39) MasterQ32: bin mal afk und grüble
(23:15:30) MasterQ32: meh, jetzt muss ich erst mal wieder umplanen wegen dem parallelen I/O-Bus
(23:15:32) MasterQ32: :D
(23:15:43) MasterQ32: danach guck ich nach dem kram mit dem stapel
(23:15:52) MasterQ32: aber wie mach ich dann sinnvoll stacking mit banking?
(23:20:55) Jonathan: MasterQ32: Äh, Zugriffe auf den Stack gibst du auch einfach durch die MMU :P
(23:21:13) Jonathan: Dann hat sich das Problem "mehrere Stacks für mehrere Tasks" auch gleich erledigt
(23:24:55) Jonathan: (Naja, musst halt den SP neu laden beim Task Switch, aber das ist ja sowieso immer so)
(23:28:53) MasterQ32: okay, klingt sinnvoll
(23:29:04) Jonathan: :D
(23:29:13) MasterQ32: das heißt, mir fallen mindestens zwei pages für die tasks weg (interrupt-page und stack-page)
(23:29:21) MasterQ32: und halt wenn der stack wächst, vielleicht auch mehr
(23:29:33) MasterQ32: hältst du 4096 pages sinnvoll
(23:29:39) MasterQ32: äääh page-größe
(23:29:59) Jonathan: Interrupt-Vektoren würde ich, ehrlich gesagt, in spezielle Register schubsen, wenn das möglich ist
(23:30:13) MasterQ32: hm, geht grade nicht
(23:30:17) Jonathan: Wieso nicht? :D
(23:30:28) MasterQ32: okay, gut
(23:30:38) MasterQ32: ich habe grade ein einzelnes bit im instruction set über
(23:30:43) Jonathan: *g*
(23:31:02) MasterQ32: damit bekomm ich doppelte befehlsmenge, damit könnte ich sowas wie nen intrset machen
(23:31:07) Jonathan: Ja :P
(23:31:09) MasterQ32: brauch ich nen intrget? :D
(23:31:13) Jonathan: Nicht wirklich
(23:31:14) MasterQ32: :D
(23:31:20) MasterQ32: write-once-speicher
(23:31:28) Jonathan: Wenn dein OS die Interrupts gerne auch noch wissen würde, kann es sie ja irgendwo anders speichern
(23:31:35) MasterQ32: okay, interrupt-tabellen in der CPU
(23:31:40) Jonathan: Ja, das macht Sinn :D
(23:31:47) Jonathan: Stack, Code und Daten in einem einzigen RAM
(23:31:55) Jonathan: Das mit dem Banking ist zwar meh, aber machbar
(23:32:04) MasterQ32: interrupt-tabellen in ihrem eigenen ram? :D
(23:32:14) Jonathan: Naja, wie viele Interrupt-Entries brauchst du denn?
(23:32:23) Jonathan: Beim Kessler gibt's nen 2k x8 SRAM für 3€ oder so
(23:32:47) MasterQ32: wir haben ja 128 devices zur verfügung, also würde ich sagen 128 interrupts are sufficient? D
(23:32:56) MasterQ32: sprich 256×8
(23:33:02) Jonathan: Gib jedem Device doch mehrere Ints
(23:33:11) Jonathan: 128 Devices zu jeweils 4 Interrupts
(23:33:18) MasterQ32: oder so, klingt auch gut
(23:33:26) Jonathan: Hmmm
(23:33:26) MasterQ32: dann hab ich 1k×8 interrupt-rahm
(23:33:33) Jonathan: Nicht ganz :D
(23:33:38) Jonathan: Du hast doch Banking.
(23:33:47) MasterQ32: wie meinst?
(23:33:51) Jonathan: Einfach an eine Adresse springen ist nicht genug, es sei denn, du hast ne fixe Kernel-Bank eingeblendet
(23:33:58) MasterQ32: stimmt
(23:34:00) Jonathan: Das würde ich persönlich aber nicht tun
(23:34:09) MasterQ32: also page-num + target-addresse
(23:34:12) Jonathan: Also würde ich 32 Bits pro Interrupt veranschlagen
(23:34:13) MasterQ32: also 2k×8 ? :D
(23:34:14) Jonathan: Genau :P
(23:34:20) MasterQ32: okay, klingt vernünftig
(23:34:31) Jonathan: Oder du machst es so:
(23:34:32) MasterQ32: und: ich hoffe, dass mir dieser IRC-Log von heute nicht abhangen kommt
(23:34:33) MasterQ32:  :D
(23:34:38) Jonathan: 256 "Devices" zu je 2 Interrupts
(23:34:57) Jonathan: Die unteren 256 wären dann Interrupts vom RAM, was keinen Sinn macht - aber mach doch Soft-IRQs draus.
(23:35:05) MasterQ32: stimmt
(23:35:17) MasterQ32: praktisch für syscalls und fast syscalls
(23:35:37) MasterQ32: "int 0x0F → jump to page" oder sowas
(23:35:38) Jonathan: Dann sind "Devices" 0..127 Soft-IRQs (= Soft-IRQ 0..255), Devices 128..255 dann die richtigen Devices zu je 2 Interrupts.
(23:35:53) Jonathan: Wieso "Jump to Page"?
(23:36:00) MasterQ32: bzw. farjump, nicht short jump
(23:36:09) Jonathan: IRQs können in deinem System ja dann die Banking-Konfiguration wechseln
(23:36:17) MasterQ32: jop
(23:36:20) Jonathan: D.h. es sind kostenlose Syscalls mit Kontextswitch :D
(23:36:24) MasterQ32: hihi
(23:36:24) Jonathan: Ach ja!
(23:36:30) Jonathan: Mach es doch so:
(23:36:46) Jonathan: In der MMU brauchst du sowieso noch einen RAM, der dir virtuelle Adressen auf physische mappt
(23:36:51) MasterQ32: genau
(23:36:53) Jonathan: (Das im richtigen RAM zu haben macht auch wenig Sinn)
(23:37:11) Jonathan: Wieso siehst du da nicht gleich mehrere Configs vor, zwischen denen du umschalten kannst?
(23:37:28) MasterQ32: kernel-config, user-config, driver-config, ...?
(23:37:30) Jonathan: Dann hat jeder Task seine Banking-Config in der MMU gespeichert und es lässt sich direkt umschalten
(23:37:41) Jonathan: Nicht nur "User-Config", sondern "Per-Task-Config"
(23:37:48) MasterQ32: ja, darum ja auch ...
(23:37:52) Jonathan: :D
(23:37:59) MasterQ32: dann kann ich aber auch gleich noch richtige MMU-Instructions einführen
(23:38:02) Jonathan: Joa
(23:38:09) MasterQ32: read/write-protection, ... :D
(23:38:16) Jonathan: Jo :P
(23:38:22) Jonathan: Dann geht aber folgendes:
(23:38:49) Jonathan: 1. Task Switch wird sehr sehr billig --> MMU-Config umschalten und SP/BP neu setzen
(23:39:17) Jonathan: 2. IRQs könnten genauso einfach die Config switchen... 16 Bit ISR-Adresse, 8 / 16 Bit Config-Nummer
(23:39:41) Jonathan: Dann kannst du mit Soft-IRQs direkt einen kompletten Context Switch in den Kernel ausführen, mit quasi 0 Hardware- und Software-Aufwand
(23:40:08) MasterQ32: ich habs zwar nicht 100% verstanden, klingt aber fancy
(23:40:28) Jonathan: Und die "MMU-Configs" kannst du implementieren, indem du wortwörtlich einfach nur den Config-RAM in der MMU größer als eine Config machst und die obersten n Bits des RAM durch ein Register ansteuerst
(23:40:39) MasterQ32: jop, das ist mir klar
(23:40:40) Jonathan: :D
(23:40:52) Jonathan: Öh, wo genau hast du es noch nicht 100% verstanden?
(23:41:10) MasterQ32: Interrupt-Config und MMU-Config sind getrennt oder zusammen?
(23:41:16) Jonathan: Getrennt
(23:41:50) Jonathan: Und die Interrupt-Config enthält pro Interrupt die (virtuelle) Adresse der ISR sowie die Nummer der MMU-Config, in die zu schalten ist
(23:42:08) MasterQ32: ah, jetzt
(23:42:27) Jonathan: Wenn du dann in nem Userspace-Programm nen IRQ bekommst, kann deine Interrupt-Hardware die MMU-Config umschalten und damit z.B. direkt in den Adressraum des Kernels umschalten
(23:42:44) Jonathan: Und dann einfach die ISR im Kernel anspringen
(23:42:47) MasterQ32: oder direkt in den treiber? :D
(23:42:50) Jonathan: Oder das :P
(23:43:01) MasterQ32: wäre weniger overhead und würde wohl auch nicht wesentlich besser/schlechter sein
(23:43:09) Jonathan: Klar
(23:43:16) Jonathan: Und Syscalls wären einfach Soft-IRQs, da die ja Context Switches durchführen können
(23:43:25) MasterQ32: jop
(23:43:39) Jonathan: Wobei man eben irgendwie Parameter übergeben müsste
(23:43:43) MasterQ32: MMU-Config dann ist (Page-Address(0…15), SP, BP)*n
(23:43:51) MasterQ32: SHM *duck*
(23:43:55) Jonathan: *g*
(23:43:57) Jonathan: Joa
(23:44:15) Jonathan: Eventuell auch noch sowas wie Supervisor-Flags
(23:44:31) MasterQ32: hm?
(23:44:53) Jonathan: Äh, wenn du in deinem System in der MMU auch Speicherschutz machen willst, dann wäre ein "Supervisor Mode" auch nicht schlecht :D
(23:45:42) MasterQ32: :D
(23:45:43) Jonathan: MMU-Config (wir sollten es lieber "Task Context" nennen) wäre dann: (Page-Adresse(0..15) x 16 Bit, Page Flags(0..7) x 8 Bit, SP, BP, Flags)*n
(23:46:27) MasterQ32: also 262 byte :D
(23:46:29) MasterQ32: IEH !: D
(23:46:35) Jonathan: Huch, 262 Byte? *g*
(23:46:58) Jonathan: 43 Bytes pro Task Context
(23:47:02) Jonathan: Äääh nee
(23:47:22) MasterQ32: 38 byte
(23:47:23) MasterQ32: jetzt :D
(23:47:29) MasterQ32: sorry, ich bin doof :D
(23:47:38) MasterQ32: also nen .align 64
(23:47:42) Jonathan: (Page-Adresse(0..15) = 16 Bit, Page Flags(0..15) = 8 Bit, SP = 16 Bit, BP = 16 Bit, Flags = 16 Bit)*n
(23:47:50) MasterQ32: ah, 16 bit flags
(23:47:58) MasterQ32: naja, sind halt dann 39 byte
(23:48:02) MasterQ32: oh wait
(23:48:08) Jonathan: Ich sehe da immer noch 54 Bytes :D
(23:48:09) MasterQ32: wir haben 16 page flags
(23:48:14) Jonathan: Ja *g*
(23:48:17) Jonathan: Da hatte ich mich verschrieben
(23:48:24) MasterQ32: so, jetzt haben wir das
(23:48:31) Jonathan: Wäre keine allzu große Verschwendung, das einfach auf 64 Bytes zu alignen
(23:48:34) MasterQ32: jop
(23:48:38) Jonathan: Wie viele Tasks willst du zulassen? :D
(23:48:41) MasterQ32: :D
(23:49:14) Jonathan: 256 wären genau 16kB für den Task-Context-RAM
(23:49:55) MasterQ32: joar, klingt irgendwo vernünftig
(23:49:58) Jonathan: Ja :D
(23:50:06) ehenkes: (14:11:57)<ehenkes>ich bitte um euere stimme: https://songcheck.hofa.de/song/1793/
(23:50:09) MasterQ32: 256 tasks sind jetzt nicht SO viele, aber wir haben ja auch nicht SO viel resourcen
(23:50:24) Jonathan: Außerdem kannst du dann ein Standard-8-Bit-Register für die oberen 8 Adressbits verwenden und alles ist sehr schön von den Bitbreiten her
(23:51:07) MasterQ32: jop
(23:51:33) Jonathan: ehenkes: Unsere Nachbarn feiern gerade lautstark Party... Doch ein starker Kontrast ;)
(23:51:38) MasterQ32: save-log ~/projects/cpu/redesign-with-jonathan.txt
(23:51:40) MasterQ32: :D
(23:51:42) Jonathan: *g*
(23:51:46) MasterQ32: so, ich mach mal pause und lass mein hirn rattern
(23:51:50) Jonathan: Jo :D
(23:51:54) MasterQ32: war ja jetzt doch viel
(23:51:56) MasterQ32: Danke dir!
(23:52:00) Jonathan: Kein Problem :P
(23:52:07) MasterQ32: wird sicher lustig, wenn das am ende mal alles läuft
(23:52:50) Jonathan: Klar :D
(23:53:16) Jonathan: Und meine CPU soll eine Art "Education-ARM" werden, also so simpel wie möglich und mit so wenig Hardware wie möglich
(23:54:29) Jonathan: MasterQ32: https://pastebin.com/j2rcHMjR
(23:54:30) Jonathan: *g*
(23:55:51) Jonathan: Wuhu, draußen singen die Schnapsleichen...
(23:58:55) Paddy left the room (quit: Quit: Konversation terminated!).
(23:59:08) ehenkes: Jonathan: sicher ein Kontrast ^^
(23:59:25) ehenkes: du brauchst da snicht gut finden, einfach voten ^^
(23:59:56) Jonathan: Ich find's aber eigentlich ganz gut, darf ich trotzdem voten? *g*
(00:00:05) ehenkes: ja
(00:00:07) Jonathan: :P
(00:36:24) stultus is now known as Guest5898
(00:38:54) derhartmut left the room (quit: User has been banned from euIRCnet).
(00:38:54) Guest5898 left the room (quit: User has been banned from euIRCnet).
(01:13:28) DesL left the room (quit: User has been banned from euIRCnet).
(02:03:11) Jonathan left the room (quit: Quit: Quit - Today's forecast: Cloudy with a chance of banhammer).
(07:49:22) The account has disconnected and you are no longer in this chat. You will automatically rejoin the chat when the account reconnects.
